
前端纳米学位街机游戏克隆项目
===============================

### 街机游戏操作指南:
                - 双击HTML文件，用浏览器打开，此时将见到虫子在页画布上移动，小人位于画布下方中间位置。

                - 用键盘上的四个方向键控制小人的移动，注意不能碰到虫子，否则游戏失败，点击确定游戏重新开始。

                - 在不碰触虫子的前提下，小人顺利抵达小河，则游戏胜利，点击确定游戏重新开始。

### 街机游戏运行原理：
　　　　　　　　　　按照js在HTML中被调用的顺序，依次解释说明。
　　　　　　　　　　`Resources.js`负责图片加载和缓存，并通过`window.Resources` 公共的资源对象来定义公有的 开发者可以访问的函数。


　　　　　　　　　　`app.js`:
　　　　　　　　　　　　　　　 `Enemy`构造函数：设置了位子、速度、图片数据;

　　　　　　　　　　　　　　　 `Enemy.prototype.update`虫子更新函数：设置防止虫子冲出画布的`if`语句,以及保证虫子以同样的速度运行的语句；

　　　　　　　　　　　　　　　 `Enemy.prototype.render`虫子渲染函数：实现被调用时在画布的指定位置用指定的图片画在画布上；


　　　　　　　　　　　　　　　 `Player`构造函数：设置了位子、速度、图片数据。设置当前状态为未赢状态;

　　　　　　　　　　　　　　   `Player.prototype.checkCollision`碰撞检测函数：当每个虫子与小人的Ｙ轴距离小于40且每个虫子与小人的Ｘ轴距离小于50时判定为碰撞，浏览器提示
                                                          　　　　　　　　失败，小人位置复位；为了能看见小人与虫子的碰撞画面，通过闭包、延时函数实现延时报警和
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　小人的位置复位以及延时将当前状态设为未赢，防止实时更新的状态不断触发`alert`；

　　　　　　　　　　　　　　　　`Player.prototype.update`小人更新函数：每次更新都调用碰撞检测函数，依据小人的Ｙ轴数值和输赢状态判定小人是否到达小河。为了能看见小人抵达小河
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　的画面，通过闭包、延时函数实现延时报警和小人的位置复位以及延时将当前状态设为未赢，防止实时更新
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　的状态不断触发`alert`；

　　　　　　　　　　　　　　　　`Player.prototype.handleInput`小人移动函数：依据侦测到的按键决定玩家如何移动。依据玩家位置和画布坐标，决定移动算法。按照引擎中绘制画布　　　　　　                                                             　　　 时的参数，决定每次的位移值；

　　　　　　　　　　　　　　　　`Player.prototype.render`小人渲染函数：实现被调用时在画布的指定位置用指定的图片画在画布上；

　　　　　　　　　　　　　　  `allEnemies`数组：存贮六只虫子；

　　　　　　　　　　　　　　　`new Player`创建小人的实例，并设置小人的初始位置参数。

                         `player.handleInput(allowedKeys[e.keyCode])`语句：实现将侦测到的方向按键传递给小人移动函数；


                　`engine.js`：浏览器一旦开始调用，`engine（）`自动执行其内部的语句：
                　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　1. 按照顺序从上往下开始执行。首先在HTML中建立了一块画布，然后开始依次声明函数`main()`、
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 `init()`、`update(dt)`、`updateEntities(dt)`、`render()`、`renderEntities()`、
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 `reset()`、`Resources.load`，执行到`Resources.onReady(init)`的时候，开始调　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　    用只执行一次的`init()`函数；

                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　2. 在`init()`函数内部，首先为`lastTime`赋值当前的时间参数，然后，调用`main()`函数；
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　3. 在`main()`函数内部，首先声明变量 `now`和`dt`,`now`表示当前的时间参数。`dt`为程序在运行到
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　`now`与`lastTime`的时间差，设备的运行速速越快差值越小，反之亦然，再乘以速度，即可保证　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　处理速度不同的设备上的虫子移动速度相同。

                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　4. 在`main()`函数内部，开始调用`update(dt)`函数，进而调用`updateEntities(dt)`。在
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　`updateEntities(dt)`内实现对`app.js`中所有的虫子和小人的实例的更新方法函数调用，更新所　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　有虫子的位置，小人的位置，以及本次更新的碰撞检测、按键移动检测、是否成功抵达小河的检测。

                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　5. 在`main()`函数内部，开始调用`render()`函数：通过循环调用图片数组的图片
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　实现在画布中对游戏图案的渲染。进而调用`renderEntities()`，　　
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　在`renderEntities()`内实现对`app.js`中所有虫子和小人的实例的渲染方法的调用，在画布上
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　画出小人和虫子。`lastTime = now`: 为`lastTime`重新赋值，因为之后开始在主函数内循环。

                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　6. 在`main()`函数内部，开始执行`win.requestAnimationFrame(main)`语句，告诉浏览器您希望执　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　行动画并请求浏览器在下一次重绘之前调用指定的函数（这里就是`main`）来更新动画。
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　
                            **至此，`main()`函数开始了由浏览器决定的自循环，画面动了起来。**　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
                              　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
